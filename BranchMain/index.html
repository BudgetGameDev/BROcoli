<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <title>Unity WebGL Player | BROcoli</title>
    
    <!-- PWA Meta Tags -->
    <link rel="manifest" href="manifest.json" id="manifest-link">
    <meta name="theme-color" content="#000000">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="BROcoli" id="app-name-meta">
    
    <!-- Staging/Release manifest detection -->
    <script>
      (function() {
        try {
          window.isStagingBuild = window.location.pathname.indexOf('/BranchMain') !== -1;
          if (window.isStagingBuild) {
            // Switch to staging manifest
            var manifestLink = document.getElementById('manifest-link');
            if (manifestLink) manifestLink.href = 'manifest-staging.json';
            
            // Fetch release manifest to get base name, then append " Staging"
            fetch('manifest.json')
              .then(function(r) { return r.json(); })
              .then(function(manifest) {
                var baseName = manifest.name || 'Web Game';
                var stagingName = baseName + ' Staging';
                document.title = stagingName;
                var appNameMeta = document.getElementById('app-name-meta');
                if (appNameMeta) appNameMeta.content = stagingName;
              })
              .catch(function() {
                // Fallback if fetch fails
                document.title = document.title + ' Staging';
              });
          }
        } catch (e) {
          // Staging detection failed - continue with defaults
          window.isStagingBuild = false;
        }
      })();
    </script>
    
    <!-- iOS Safari specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BROcoli">
    <meta name="format-detection" content="telephone=no">
    
    <!-- iOS icons -->
    <link rel="apple-touch-icon" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/icon-192x192.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-152x152.png">
    
    <!-- Favicon -->
    <link rel="icon" type="image/png" sizes="192x192" href="icons/icon-192x192.png">
    <link rel="icon" type="image/png" sizes="32x32" href="icons/icon-96x96.png">
    
    <!-- PWA Install Wizard Styles -->
    <link rel="stylesheet" href="pwa-install.css">
    
    <!-- Version Check Script (must load early) -->
    <script src="version-check.js"></script>
    
    <style>
      /* Full-screen dark background to fill areas outside 16:9 aspect ratio */
      html, body {
        margin: 0;
        padding: 0;
        width: 100%;
        height: 100%;
        overflow: hidden;
        background-color: #000000;
      }
      
      #unity-canvas {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        /* Prevent touch callouts and text selection on iOS */
        -webkit-touch-callout: none;
        -webkit-user-select: none;
        user-select: none;
        /* Ensure touch events work properly */
        touch-action: none;
        /* Ensure it fills completely */
        object-fit: cover;
      }
      
      /* iOS Safari fullscreen fix */
      @supports (-webkit-touch-callout: none) {
        html, body {
          /* Use viewport units that account for iOS Safari's dynamic toolbar */
          height: 100%;
          min-height: 100vh;
          min-height: -webkit-fill-available;
          min-height: 100dvh;
        }
        #unity-canvas {
          height: 100%;
          min-height: 100vh;
          min-height: -webkit-fill-available;
          min-height: 100dvh;
        }
      }
      
      /* PWA Standalone mode - truly fullscreen */
      @media all and (display-mode: standalone), all and (display-mode: fullscreen) {
        html, body {
          /* Remove any padding that might interfere */
          padding: 0 !important;
        }
        #unity-canvas {
          /* Ensure full coverage in standalone mode */
          width: 100vw !important;
          height: 100vh !important;
          height: 100dvh !important; /* Dynamic viewport height */
        }
      }
      
      /* Loading screen */
      #loading-screen {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: #000000;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        z-index: 1000;
        transition: opacity 0.5s ease;
      }
      
      #loading-screen.hidden {
        opacity: 0;
        pointer-events: none;
      }
      
      .loading-spinner {
        width: 60px;
        height: 60px;
        border: 4px solid rgba(255, 255, 255, 0.2);
        border-top-color: #ffffff;
        border-radius: 50%;
        animation: spin 1s linear infinite;
      }
      
      @keyframes spin {
        to { transform: rotate(360deg); }
      }
      
      .loading-text {
        color: #a0a0a0;
        margin-top: 20px;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        font-size: 14px;
      }
      
      .loading-progress {
        width: 200px;
        height: 4px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 2px;
        margin-top: 15px;
        overflow: hidden;
      }
      
      .loading-progress-bar {
        width: 0%;
        height: 100%;
        background: #ffffff;
        border-radius: 2px;
        transition: width 0.3s ease;
      }
      
      /* ==================== Game UI Overlay ==================== */
      #game-ui-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 100;
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Noto Sans', Helvetica, Arial, sans-serif;
      }
      
      #game-ui-overlay.visible {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: flex-start;
        padding-top: 8%;
      }
      
      #game-ui-overlay * {
        pointer-events: auto;
      }
      
      /* CTA Container */
      .cta-container {
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 12px;
      }
      
      .cta-header {
        color: rgba(255, 255, 255, 0.7);
        font-size: 14px;
        font-style: italic;
        margin-bottom: 4px;
      }
      
      /* GitHub Star Button - matching GitHub's exact style */
      .github-star-btn {
        display: inline-flex;
        align-items: center;
        background: transparent;
        border: 1px solid rgba(240, 246, 252, 0.1);
        border-radius: 6px;
        overflow: hidden;
        font-family: inherit;
        cursor: pointer;
      }
      
      .github-star-btn .btn-content {
        display: inline-flex;
        align-items: center;
        gap: 6px;
        padding: 5px 12px;
        background: #21262d;
        color: #c9d1d9;
        font-size: 14px;
        font-weight: 500;
        border: none;
        border-right: 1px solid rgba(240, 246, 252, 0.1);
        transition: background-color 0.1s ease;
        text-decoration: none;
      }
      
      .github-star-btn .btn-content:hover {
        background: #30363d;
      }
      
      .github-star-btn .btn-content:active {
        background: #282e33;
      }
      
      .github-star-btn .btn-content svg {
        fill: #8b949e;
        width: 16px;
        height: 16px;
        flex-shrink: 0;
      }
      
      .github-star-btn .star-count {
        display: inline-flex;
        align-items: center;
        padding: 5px 12px;
        background: #21262d;
        color: #c9d1d9;
        font-size: 14px;
        font-weight: 600;
        transition: background-color 0.1s ease;
        text-decoration: none;
      }
      
      .github-star-btn .star-count:hover {
        background: #30363d;
        color: #58a6ff;
      }
      
      /* Score display */
      .score-display {
        color: white;
        font-size: 32px;
        font-weight: 600;
        margin-bottom: 8px;
        text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      }
      
      /* Steam button (hidden by default, for future use) */
      .steam-wishlist-btn {
        display: none;
        align-items: center;
        gap: 8px;
        padding: 8px 16px;
        background: linear-gradient(to right, #1b2838, #2a475e);
        color: #66c0f4;
        font-size: 14px;
        font-weight: 500;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        transition: all 0.2s ease;
        text-decoration: none;
      }
      
      .steam-wishlist-btn:hover {
        background: linear-gradient(to right, #2a475e, #3d6a8a);
        color: #ffffff;
      }
      
      .steam-wishlist-btn.visible {
        display: inline-flex;
      }
      
      /* Responsive adjustments */
      @media screen and (max-width: 600px) {
        .cta-header {
          font-size: 12px;
        }
        .github-star-btn .btn-content,
        .github-star-btn .star-count {
          padding: 4px 10px;
          font-size: 13px;
        }
        .github-star-btn .btn-content svg {
          width: 14px;
          height: 14px;
        }
        .score-display {
          font-size: 24px;
        }
      }
      
      /* Staging build info overlay - only visible on staging builds */
      #staging-build-info {
        display: none;
        position: fixed;
        bottom: 4px;
        right: 8px;
        color: rgba(255, 255, 255, 0.6);
        font-family: monospace;
        font-size: 10px;
        z-index: 99999;
        pointer-events: none;
        text-shadow: 0 0 2px rgba(0, 0, 0, 0.8);
        white-space: nowrap;
      }
    </style>
  </head>
  <body style="text-align: center; padding: 0; border: 0; margin: 0; background-color: #000000;">
    <!-- Staging Build Info Overlay (only shown on staging builds) -->
    <div id="staging-build-info"></div>
    
    <!-- Loading Screen -->
    <div id="loading-screen">
      <div class="loading-spinner"></div>
      <div class="loading-text">Loading game...</div>
      <div class="loading-progress">
        <div class="loading-progress-bar" id="loading-progress-bar"></div>
      </div>
    </div>
    
    <canvas id="unity-canvas" style="width: 100%; height: 100%; position: fixed; top: 0; left: 0; background: #000000;"></canvas>
    
    <!-- Game UI Overlay (controlled by Unity via JS bridge) -->
    <div id="game-ui-overlay">
      <div class="cta-container">
        <div class="github-star-btn">
          <a href="https://github.com/BudgetGameDev/BROcoli" target="_blank" rel="noopener" class="btn-content">
            <svg aria-hidden="true" height="16" viewBox="0 0 16 16" version="1.1" width="16">
              <path d="M8 .25a.75.75 0 0 1 .673.418l1.882 3.815 4.21.612a.75.75 0 0 1 .416 1.279l-3.046 2.97.719 4.192a.751.751 0 0 1-1.088.791L8 12.347l-3.766 1.98a.75.75 0 0 1-1.088-.79l.72-4.194L.818 6.374a.75.75 0 0 1 .416-1.28l4.21-.611L7.327.668A.75.75 0 0 1 8 .25Z"></path>
            </svg>
            Star
          </a>
          <a href="https://github.com/BudgetGameDev/BROcoli/stargazers" target="_blank" rel="noopener" class="star-count" id="github-star-count">--</a>
        </div>
        <!-- Steam wishlist button (hidden for now) -->
        <a href="#" class="steam-wishlist-btn" id="steam-wishlist-btn">
          Wishlist on Steam
        </a>
      </div>
    </div>
    
    <!-- PWA Install Wizard Script -->
    <script src="pwa-install.js"></script>
    
    <script src="Build/WebGL.loader.js"></script>
    <script>
      // Platform detection (wrapped for safety)
      var isiOS = false;
      var isMacWithTouch = false;
      var isiOSDevice = false;
      var isSafari = false;
      var isMobile = false;
      var isStandalone = false;
      
      try {
        isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
        isMacWithTouch = (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        isiOSDevice = isiOS || isMacWithTouch;
        isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
        isMobile = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent) || isiOSDevice;
        isStandalone = window.matchMedia('(display-mode: standalone)').matches || 
                       window.matchMedia('(display-mode: fullscreen)').matches ||
                       window.navigator.standalone === true;
      } catch (e) {
        // Platform detection failed - use safe defaults
      }
      
      // Audio context reference for Unity's audio (not running background oscillator)
      var audioKeepAlive = null;
      
      // Patch canvas.getContext for high-performance GPU before Unity loads
      try {
        (function() {
          var originalGetContext = HTMLCanvasElement.prototype.getContext;
          HTMLCanvasElement.prototype.getContext = function(type, attributes) {
            if (type === 'webgl' || type === 'webgl2' || type === 'experimental-webgl') {
              attributes = attributes || {};
              attributes.powerPreference = 'high-performance';
              attributes.preserveDrawingBuffer = false;
            }
            return originalGetContext.call(this, type, attributes);
          };
        })();
      } catch (e) { /* getContext patch failed - continue */ }
      
      // ProMotion frame monitoring removed - was consuming background CPU
      
      // Screen wake lock
      var wakeLock = null;
      async function requestWakeLock() {
        if ('wakeLock' in navigator) {
          try {
            wakeLock = await navigator.wakeLock.request('screen');
          } catch (e) {}
        }
      }
      
      // Visibility API - force canvas wake on tab visibility change
      document.addEventListener('visibilitychange', function() {
        if (!document.hidden) {
          // Re-acquire wake lock
          if (wakeLock === null) requestWakeLock();
          // Force style recalc to wake up rendering pipeline
          var c = document.getElementById('unity-canvas');
          if (c) {
            c.style.display = 'none';
            c.offsetHeight;
            c.style.display = 'block';
          }
        }
      });
      
      // Experimental Scheduler API - request high priority for main thread tasks
      // This is a hint to the browser that our tasks are user-blocking
      try {
        if ('scheduler' in window && 'postTask' in window.scheduler) {
          // Wrap requestAnimationFrame to use high priority scheduling
          var originalRAF = window.requestAnimationFrame;
          window.requestAnimationFrame = function(callback) {
            return window.scheduler.postTask(function() {
              return originalRAF(callback);
            }, { priority: 'user-blocking' });
          };
        }
      } catch (e) { /* Scheduler API patch failed - continue */ }
      
      // Keep-alive removed - was consuming background CPU
      
      // Device motion permission - iOS Safari throttles less when it detects device is being held
      function requestDeviceMotion() {
        if ('DeviceMotionEvent' in window && typeof DeviceMotionEvent.requestPermission === 'function') {
          DeviceMotionEvent.requestPermission().catch(function() {});
        }
      }
      
      // WebGL context loss handling - iOS Safari has hard limits on WebGL contexts
      function setupContextLossHandling() {
        var canvas = document.getElementById('unity-canvas');
        if (!canvas) return;
        canvas.addEventListener('webglcontextlost', function(e) {
          e.preventDefault();
        });
        canvas.addEventListener('webglcontextrestored', function() {
          // Unity should auto-recover but we force a resize to help
          window.dispatchEvent(new Event('resize'));
        });
      }
      
      // Battery API - always request high performance, track charging state
      function checkBatteryStatus() {
        // Always signal we want high performance regardless of battery
        document.body.setAttribute('data-performance-mode', 'high');
        
        if ('getBattery' in navigator) {
          navigator.getBattery().then(function(battery) {
            document.body.setAttribute('data-charging', battery.charging ? 'true' : 'false');
            document.body.setAttribute('data-battery-level', Math.round(battery.level * 100));
            
            battery.addEventListener('chargingchange', function() {
              document.body.setAttribute('data-charging', battery.charging ? 'true' : 'false');
            });
            battery.addEventListener('levelchange', function() {
              document.body.setAttribute('data-battery-level', Math.round(battery.level * 100));
            });
          }).catch(function() {});
        }
      }
      
      // Touch feedback hint - forces Safari to prepare for touch interaction
      function setupTouchHints() {
        document.body.style.webkitTapHighlightColor = 'transparent';
        document.body.style.touchAction = 'manipulation';
      }
      
      // requestIdleCallback fallback for Safari (still not supported in 2026)
      // if (!('requestIdleCallback' in window)) {
      //   window.requestIdleCallback = function(cb) {
      //     var start = Date.now();
      //     return setTimeout(function() {
      //       cb({
      //         didTimeout: false,
      //         timeRemaining: function() {
      //           return Math.max(0, 50 - (Date.now() - start));
      //         }
      //       });
      //     }, 1);
      //   };
      //   window.cancelIdleCallback = function(id) {
      //     clearTimeout(id);
      //   };
      // }
      
      // Start iOS optimizations (all wrapped for safety)
      if (isiOSDevice) {
        try { requestWakeLock(); } catch (e) {}
        try { setupContextLossHandling(); } catch (e) {}
        try { checkBatteryStatus(); } catch (e) {}
        try { setupTouchHints(); } catch (e) {}
        // Request device motion on first touch (requires user gesture)
        try {
          document.addEventListener('touchstart', function() {
            try { requestDeviceMotion(); } catch (e) {}
            // Resume audio context if needed (one-time on first touch)
            try {
              if (audioKeepAlive && audioKeepAlive.state === 'suspended') {
                audioKeepAlive.resume();
              }
            } catch (e) {}
          }, { once: true });
        } catch (e) {}
      }
      
      // Orientation lock (wrapped for safety)
      function tryLockLandscape() {
        try {
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(function() {});
          }
        } catch (e) {}
      }
      try { tryLockLandscape(); } catch (e) {}
      
      // Viewport meta (wrapped for safety)
      try {
        var meta = document.createElement('meta');
        meta.name = 'viewport';
        if (isiOSDevice) {
          meta.content = 'width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover';
        } else {
          meta.content = 'width=device-width, height=device-height, initial-scale=1.0, user-scalable=no, shrink-to-fit=yes';
        }
        document.getElementsByTagName('head')[0].appendChild(meta);
      } catch (e) {}

      var canvas = document.querySelector("#unity-canvas");
      var loadingScreen = document.getElementById('loading-screen');
      var progressBar = document.getElementById('loading-progress-bar');
      var gameUIOverlay = document.getElementById('game-ui-overlay');
      
      // ==================== Game UI Bridge ====================
      // This allows Unity to control HTML UI elements
      window.GameUI = {
        // Cache the star count to avoid multiple API calls
        _starCountFetched: false,
        _starCount: null,
        
        // Fetch GitHub star count
        fetchStarCount: function() {
          if (this._starCountFetched) return;
          this._starCountFetched = true;
          
          var countEl = document.getElementById('github-star-count');
          
          fetch('https://api.github.com/repos/BudgetGameDev/BROcoli')
            .then(function(response) { 
              if (!response.ok) throw new Error('API request failed');
              return response.json(); 
            })
            .then(function(data) {
              if (data && typeof data.stargazers_count === 'number') {
                window.GameUI._starCount = data.stargazers_count;
                if (countEl) {
                  countEl.textContent = data.stargazers_count;
                }
              }
            })
            .catch(function() {
              if (countEl && countEl.textContent === '--') {
                countEl.textContent = '0';
              }
            });
        },
        
        showEndGameCTA: function(score, minScore) {
          minScore = minScore || 0;
          if (score < minScore) return;
          this.fetchStarCount();
          if (gameUIOverlay) gameUIOverlay.classList.add('visible');
        },
        
        hideEndGameCTA: function() {
          if (gameUIOverlay) gameUIOverlay.classList.remove('visible');
        },
        
        // Show/hide Steam wishlist button (for future use)
        showSteamButton: function(show) {
          var btn = document.getElementById('steam-wishlist-btn');
          if (btn) {
            if (show) {
              btn.classList.add('visible');
            } else {
              btn.classList.remove('visible');
            }
          }
        }
      };
      
      // Pre-fetch star count early so it's ready when needed
      setTimeout(function() {
        window.GameUI.fetchStarCount();
      }, 3000); // Wait 3 seconds after page load
      
      // Function to check if we're in portrait mode
      function isPortrait() {
        return window.innerHeight > window.innerWidth;
      }
      
      // Function to update canvas resolution to match window size
      function updateCanvasSize() {
        var dpr = window.devicePixelRatio || 1;
        var width = window.innerWidth;
        var height = window.innerHeight;
        
        // In standalone mode, use full viewport
        if (isStandalone) {
          // Use visualViewport if available for more accurate sizing
          if (window.visualViewport) {
            width = window.visualViewport.width;
            height = window.visualViewport.height;
          }
        }
        
        // For iOS Safari, use document dimensions as fallback
        if (isiOSDevice && !isStandalone) {
          width = Math.max(width, document.documentElement.clientWidth);
          height = Math.max(height, document.documentElement.clientHeight);
        }
        
        // Set the canvas drawing buffer size (actual resolution Unity renders at)
        canvas.width = Math.floor(width * dpr);
        canvas.height = Math.floor(height * dpr);
        
        // Set CSS size to fill screen completely
        canvas.style.width = width + 'px';
        canvas.style.height = height + 'px';
        canvas.style.position = 'fixed';
        canvas.style.top = '0';
        canvas.style.left = '0';
      }
      
      // Full-screen canvas setup
      canvas.style.position = "fixed";
      canvas.style.top = "0";
      canvas.style.left = "0";
      canvas.style.touchAction = "none"; // Prevent browser touch gestures
      canvas.style.webkitTouchCallout = "none"; // Prevent iOS callouts
      canvas.style.webkitUserSelect = "none"; // Prevent text selection
      
      document.body.style.textAlign = "left";
      document.body.style.backgroundColor = "#000000";
      document.documentElement.style.backgroundColor = "#000000";
      
      // Initial size update
      updateCanvasSize();
      
      // Handle resize events for all platforms
      window.addEventListener('resize', function() {
        updateCanvasSize();
      });
      
      // Handle visual viewport changes (for virtual keyboards, etc.)
      if (window.visualViewport) {
        window.visualViewport.addEventListener('resize', function() {
          updateCanvasSize();
        });
      }
      
      // iOS Safari specific touch handling
      if (isiOSDevice) {
        // Prevent default touch behaviors that interfere with game input
        document.addEventListener('touchstart', function(e) {
          if (e.target === canvas) {
            e.preventDefault();
          }
        }, { passive: false });
        
        document.addEventListener('touchmove', function(e) {
          if (e.target === canvas) {
            e.preventDefault();
          }
        }, { passive: false });
        
        // Prevent iOS Safari's bounce/elastic scrolling
        document.body.style.overflow = 'hidden';
        document.body.style.position = 'fixed';
        document.body.style.width = '100%';
        document.body.style.height = '100%';
      }
      
      // Try to auto-enter fullscreen on user interaction (for non-PWA mobile)
      if (isMobile && !isStandalone) {
        var hasRequestedFullscreen = false;
        
        function tryFullscreen() {
          if (hasRequestedFullscreen) return;
          hasRequestedFullscreen = true;
          
          var elem = document.documentElement;
          if (elem.requestFullscreen) {
            elem.requestFullscreen().then(function() {
              // Try to lock orientation after entering fullscreen
              tryLockLandscape();
            }).catch(function() {});
          } else if (elem.webkitRequestFullscreen) {
            elem.webkitRequestFullscreen();
            // Try to lock orientation after entering fullscreen
            setTimeout(tryLockLandscape, 100);
          }
        }
        
        // Request fullscreen on first touch (if not in PWA mode)
        canvas.addEventListener('touchstart', function() {
          // Small delay to ensure PWA prompt has been handled
          setTimeout(tryFullscreen, 100);
        }, { once: true });
      }
      
      // Handle orientation change events
      if (screen.orientation) {
        screen.orientation.addEventListener('change', function() {
          setTimeout(updateCanvasSize, 100);
        });
      }
      
      // Also listen for window orientation change (iOS)
      window.addEventListener('orientationchange', function() {
        setTimeout(updateCanvasSize, 100);
        setTimeout(updateCanvasSize, 300);
        setTimeout(updateCanvasSize, 500);
      });

      // Register Service Worker for PWA (all errors silently ignored - game must load)
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', function() {
          try {
            navigator.serviceWorker.register('sw.js')
              .then(function(registration) {
                try {
                  registration.update();
                  registration.addEventListener('updatefound', function() {
                    var newWorker = registration.installing;
                    if (newWorker) {
                      newWorker.addEventListener('statechange', function() {});
                    }
                  });
                } catch (e) { /* ignore */ }
              })
              .catch(function() { /* Service worker registration failed - continue anyway */ });
          } catch (e) { /* ignore */ }
        });
        
        try {
          navigator.serviceWorker.addEventListener('message', function(event) {
            if (event.data && event.data.type === 'NEW_VERSION_AVAILABLE') {
              var loadingText = document.querySelector('.loading-text');
              if (loadingText) {
                loadingText.textContent = 'New version found! Updating...';
              }
              setTimeout(function() {
                window.location.reload(true);
              }, 500);
            }
          });
          
          // Only reload on controller change if game hasn't started yet
          var gameStarted = false;
          window.addEventListener('unity-game-started', function() { gameStarted = true; });
          navigator.serviceWorker.addEventListener('controllerchange', function() {
            if (!gameStarted) {
              window.location.reload(true);
            }
          });
        } catch (e) { /* ignore */ }
      }

      // Function to start the Unity game
      function startUnityGame() {
        createUnityInstance(document.querySelector("#unity-canvas"), {
          dataUrl: "Build/WebGL.data",
          frameworkUrl: "Build/WebGL.framework.js",
          codeUrl: "Build/WebGL.wasm",
          streamingAssetsUrl: "StreamingAssets",
          companyName: "BudgetGameDev",
          productName: "BROcoli",
          productVersion: "0.0.150",
          matchWebGLToCanvasSize: true, // Enable dynamic resolution to match canvas size
          devicePixelRatio: window.devicePixelRatio || 1, // Use device pixel ratio for sharp rendering
          // WebGL context attributes for performance
          webglContextAttributes: {
            powerPreference: 'high-performance',
            preserveDrawingBuffer: false,
            failIfMajorPerformanceCaveat: false
          },
          // Progress callback
          onProgress: function(progress) {
            if (progressBar) {
              progressBar.style.width = (progress * 100) + '%';
            }
          }
        }).then(function(unityInstance) {
          window.unityInstance = unityInstance;
          
          // Signal that game has started (prevents service worker reload interrupts)
          window.dispatchEvent(new Event('unity-game-started'));
          
          if (loadingScreen) {
            loadingScreen.classList.add('hidden');
            setTimeout(function() {
              loadingScreen.style.display = 'none';
            }, 500);
          }
          
          updateCanvasSize();
          
          // iOS Safari cache warmup - ensure all critical files are cached for offline use
          // Run this after successful load to prevent offline issues on next app restart
          try {
            if ('serviceWorker' in navigator && navigator.serviceWorker.controller && (isiOSDevice || isMobile)) {
              setTimeout(function() {
                try {
                  // Get the current page's build file URLs from the loader
                  var buildFiles = [
                    'Build/WebGL.data',
                    'Build/WebGL.framework.js',
                    'Build/WebGL.wasm',
                    './index.html',
                    './manifest.json',
                    './version-check.js',
                    './pwa-install.js',
                    './pwa-install.css'
                  ];
                  
                  // Convert relative URLs to absolute
                  var baseUrl = window.location.href.split('?')[0].replace(/\/[^\/]*$/, '/');
                  var absoluteUrls = buildFiles.map(function(url) {
                    return new URL(url, baseUrl).href;
                  });
                  
                  console.log('[CacheWarmup] Requesting cache warmup for', absoluteUrls.length, 'files');
                  navigator.serviceWorker.controller.postMessage({
                    type: 'WARMUP_CACHE',
                    urls: absoluteUrls
                  });
                } catch (e) {
                  console.warn('[CacheWarmup] Error:', e);
                }
              }, 3000); // Wait 3 seconds after game loads
            }
          } catch (e) { /* ignore */ };
        }).catch(function(error) {
          console.warn('[Unity] createUnityInstance failed:', error);
          
          // iOS Safari edge case: Sometimes fetch fails on first try after force-close
          // but cache is actually available. Auto-retry once before showing error.
          if (!window._unityRetryAttempted) {
            window._unityRetryAttempted = true;
            console.log('[Unity] First load failed, auto-retrying in 1 second...');
            
            var loadingText = document.querySelector('.loading-text');
            if (loadingText) {
              loadingText.textContent = 'Retrying...';
            }
            
            // Wait a moment for service worker to fully initialize
            setTimeout(function() {
              console.log('[Unity] Retrying game load...');
              startUnityGame();
            }, 1000);
            return;
          }
          
          // Second attempt also failed - check if we should show offline message
          if (loadingScreen) {
            var errorMessage = (error && error.message) ? error.message : 'Could not load game files.';
            
            // Provide helpful message based on state
            if (!navigator.onLine) {
              // Check if service worker is active (files should be cached)
              if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
                errorMessage = 'Loading failed. Try closing and reopening the app.';
              } else {
                errorMessage = 'You appear to be offline. Please connect to the internet to download the game, then you can play offline.';
              }
            }
            
            loadingScreen.innerHTML = '<div style="color: #ff6b6b; font-family: sans-serif; text-align: center; padding: 20px;"><h2>Failed to load game</h2><p>' + errorMessage + '</p><button onclick="window._unityRetryAttempted=false;location.reload()" style="padding: 10px 20px; margin-top: 10px; cursor: pointer; background: #333; color: #fff; border: none; border-radius: 4px;">Retry</button></div>';
          }
        });
      }
      
      // Check for updates before starting the game
      // This runs only at page load and will reload the page if an update is found
      // CRITICAL: Any errors must be ignored - game MUST try to load regardless
      try {
        if (window.VersionChecker && typeof window.VersionChecker.checkForUpdates === 'function') {
          window.VersionChecker.checkForUpdates()
            .then(function() {
              startUnityGame();
            })
            .catch(function(err) {
              console.warn('[Startup] Version check failed, starting game anyway:', err);
              startUnityGame();
            });
        } else {
          startUnityGame();
        }
      } catch (e) {
        console.warn('[Startup] Version checker error, starting game anyway:', e);
        startUnityGame();
      }
      
      // Show staging build info overlay (only on staging builds)
      try {
        if (window.isStagingBuild) {
          fetch('version.json?_=' + Date.now())
            .then(function(r) { return r.json(); })
            .then(function(version) {
              var overlay = document.getElementById('staging-build-info');
              if (overlay && version) {
                var info = version.buildId || 'unknown';
                if (version.buildTimestamp) {
                  info += ' | ' + version.buildTimestamp;
                }
                overlay.textContent = 'STAGING: ' + info;
                overlay.style.display = 'block';
              }
            })
            .catch(function() {
              var overlay = document.getElementById('staging-build-info');
              if (overlay) {
                overlay.textContent = 'STAGING BUILD';
                overlay.style.display = 'block';
              }
            });
        }
      } catch (e) { /* staging overlay failed - non-critical */ }
      
      // Global error handler - prevent uncaught errors from breaking the game
      window.addEventListener('error', function(e) {
        console.warn('[Global] Uncaught error (game continues):', e.message);
        // Don't prevent default - let errors log to console
      });
      window.addEventListener('unhandledrejection', function(e) {
        console.warn('[Global] Unhandled promise rejection (game continues):', e.reason);
        // Prevent the rejection from being treated as an error
        e.preventDefault();
      });
    </script>
  </body>
</html>
